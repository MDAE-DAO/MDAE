@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
----------------------------------------
Fourth aproach ## ---> Contract on the Token <--- Solves all problems of visibility, concurrency and ownership:
----------------------------------------
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

We have seen the problems if we take the aproach to send the tokens into an script and then when the user
(Advertiser) who install the DAO and register the script cannot see the tokens available on it, as they where
deposited before he registered the script on his node, and the same happens in the case a user wants to buy
tokens that are into script on the DAO, and the huge amount of tokens that would be tracked by all the nodes
implied with the script aproach and the concurrency problems that may arise.

To follow the other aproaches studied before taking this solution, you need to watch the document:
mdae_dao_script_problem_tests.txt which describe the aproaches and the tests done as well as the MDAE channel on
the discord Minima server MIC section.


####################
- ADVERTISER BUY TOKENS - ## The choosen solution: ##
####################

To avoid the problem of visibililty of the tokens, instead to use an script to deposit the tokens, we used
a wallet address hardcoded on the DAO app that points to the originalDAO's node (there could also be several
of them, decentralizing the original DAO between several different nodes, so the original DAO could have
a list of hardcoded addresses where to buy tokens) or in the future gather that list from an external source,
that way, instead of the Advertiser to ask for a token to be deposited into an script addres, directly ask for buy
the tokens, sending the total minimas needed to buy the tokens desired, to rule that behavior state variables
will be used set as described on ## SECOND APROACH ## and once the minimas have been received on the Original DAO's
address and all is checked, the tokens bought are sent to the advertiser wallet and the transaction is register on
the SQL database to avoid double buy problem.

Procedure:
 - Advertiser send the minimas to the wallet's DAO (original) needed to buy the desired token and all info needed to
 make the process possible.

  state_vars:
    0:[buy_tokens],
    1:wallet buyer,
    2:token to buy,
    3: amount to buy


######################
- MDAE SCRIPT OF TOKENS and How the system works - ## The choosen solution: ##
######################

  The whole tokens of the same type must be generated at once so they can have the same tokenid and then act
  as a full syncronized ecosystem, so, the script that rules the tokens must be set on the tokens itself
  instead on an script address(to avoid the problems of we described previsouly).

  This makes the script to build more complex, but every token can act independently and here we must
  consider how the system is going to deal with the rewards to be received by all parties when a token
  is spent and the problems that may arise, so lets to consider the followings things to get an an
  overview of the complexity:

  0.  DAO_Dapp it holds the tokens and several service as descrived on the MDAE project, but for the proof of Concept
      it will only hold the tokens to be bought by Advertiser's and send them to the VAULT (A multisig script) in the first
      place, then according to the demand the tokens of the VAULT will be moved to the DAO and splitted to avoid the problems of how
      UTXO system works as well as, on every bought of tokens, the minimas received are also sent to the VAULT and the
      DAO it also runs a background service on service.js that manages the buy of tokens when the DApp is not open
      on the Node where it is running.

  1.- When the advertiser has bought tokens he must configure them according to the campaign he wants to do,
      he will get that information from the TrackerDAPP, where users and developers register their addresses and
      DApps in order to be able to receive publicity.

      - The Adverstier using Advertiser_Dapp must configure the tokens of a particular campaign with all the information
      needed as state variables, until the token is not configured it cannot be sent to anyone.

      - Once the token is configured, the Advertiser must send the tokens of the campaing to the final users scripts,
      (every final user will have a unique script based on his wallet address and if there is a third party like a DAPP,
      the wallet of this DAPP(the developer)) as well as the rewards every party must receive when the token's Publicity
      is watched.

      - After a period of time,if the token of publicity has not been watched by final user, the Advertiser can claim
      the token(s) back and the rewards related to it/them and then configure them again for another campaing.

      - (If the exact amounts of rewards are not sent and the coinid of them is not tracked on state variables, then
      it may arise problems with the burn mechanism, as a final user may have several tokens and rewards on the same script,
      and when the token is spent it should spent the exactly rewards related to the token that were sent ), on this
      proof of concept we are not going to consider this scenario in order to simplify things.


  3.- TrackerDAPP This is de DApp that advertisers, developers of DApps and users would use to register their wallets or
      would gather information in case of Advertisers or let final users to watch the publicity tokens that are on
      their node.
      Two possibilities:

          1.- The TrackerDAPP will have the DAO wallet address hardcoded, as the DAO_Dapp have a service.js running in background
              it would also be used to save all data registered by TrackerDAPP.

          2-  The TrackerDAPP will have a wallet hardcoded and another DAPP(running on other node) that give support to TrackerDAPP
              that will have a service.js that will run in background and saves all data users, developers registers on SQL
              database as DAO_DApp does, as well as give information to Advertisers when they ask interachangin tokens with
              state variables(fractions of minimas).

      - Register users and Dapps of developers.

        - DApp (developer):
          The developer register his DApp with the wallet where he want to receive the rewards, the Name of the Dapp
          and the utility of his DApp (sports, news, technology, games, .....)

          Every developer DApp must include tracker.js API, that it must register the wallet of the developer and the wallet of
          the user, as with the wallet of the developer and the wallet of the user who has installed the DAPP, the API know if
          the user's node has received publicity tokens to be shown on this DAPP, as with these two wallets it generates
          a unique script address the same way the Advertiser will use the two wallets to know where to send the token and
          the rewards asociated with it.

        - Final User:
          The final user register his wallet where to receive the rewards that will come from watching publicity tokens.
          The final user also specify what topics he is interested on (sports, news, technology, games....)
          The final user also specify on which DApps, he has installed, wants to receive publicity.

        - The trackerDAPP will let to the final user to watch the publicity tokens that has been received on his node,
          as a tab or a popup, where the app show the tokens received and the user choose one token to watch his publicity.

        -Advertiser User:
          Will ask for information of users, dapps, and topics, and the TrackerDapp will use (DAO or other DAPP support)
          background services to ask and deliver that information directly to the Advertiser with a fraction of a minima with all
          info set as state variables. (this is a proof of concept, on a real system, Omnia could be used to transfer This
          information on a batch of tokens sent, as it can be very large amount of data, Maxima could also be considered, but it has problems too, but
          the must common aproach is to use an external service to deliver that data).

          There is a real possibility to use Maxima, as in this case it makes sense as there can be a lot of information to be
          transfered from SQL resuts of DAO background service.
          In that case, we can establish some kind of handshake protocol to transmit the MAXIMA contact between
          the Advertiser User and the DAO using the same way descrived earlier with state variables.
          Flow of Events:
            - Advertiser send a fraction of a minima to the DAO setting some state variables on it.
              - ** State 0 ** : [Data_query_advertiser] The advertiser tells DAO he wants some data.
              - ** State 1-5 ** : [data1, data2, data2....] a list of data the advertiser wants (topic, users, dapps,)
              - ** State 6-10** : [Maxima data contact] The Advertiser's Maxima contact splitted into several state vars if the size of it
                overflows the size of one state variable.
            - The DAO get the MAXIMA's contact of the advertiser and sets his contact.
            - The DAO send a MAXIMA message to Advertiser [Confirm connection] and waits for the answer of ADVERTISER
            - The DAO receives MAXIMA message [connection established] from Advertiser.
            - The DAO gets all data requestes by the Advertiser and encapsulate it on a JSON object and send the
              JSON object over maxima.
            - The Advertiser receives over MAXIMA the JSON object with the data requested.
            - The Advertiser uses that information to configure the Tokens for his advertisng campaign.
            - The Advertiser confirms to the DAO that information is recevied [Information_received]
            - The DAO unsets Advertiser MAXIMA's contact from his node as there is a limit on how many contacts
              a node can manage.

      -API tracker:
          It is a simple javascript, that the DAPPS that want to show token's publicity on the DAPP must include,
          the API when the app started for first time, uses the hardcoded developers address and ask for the user's wallet
          and with these two addresses register a unique script on the user node where the Advertisers will sent the
          publicity tokens and the rewards asociated with it.

          Then the API only checks for a NEWBALANCE event and checks if there is a publicity's token on this script's
          address and if one is found, the publicity of the token is shown in the part of the DAPP designed to show
          the publicity or a popup or whatever option is choosed.

          The API also checks if the publiciy is watched (easy option for now, it is clicked) and then trigger
          a javascript function that builds a transaction satisying all conditions set on the publicity token
          sending back to the DAO.

    4. Final user script.
      As we said earlier, the Advertisers sent the publicity tokens and rewards to the final user, on a script
      that is unique as is built with the user wallet or a combination of user wallet and Dapp(developer) address.
      So this script only controls that a token of publicity must be sent back to the DAO and the minima rewards
      must be sent to the VAULT as the user cannot extract the rewards manually, the rest of payment rewards and
      the comissions of the DAO will be checked by the TOKEN's script but the transaction must specify everyone of
      those requirements , otherwise it will fail.

    5. SCRIPT MDAE:
 -------------------------------------------------------------------------
      - First part  ## BUY TOKENS ##:
 -------------------------------------------------------------------------
      /*  Dao owners let transfer the tokens from the vault to DAO address (PREVSTAE 4) where buyers will buy the tokens
          There is no need to preserve the states (4-5) if there is not a buy
      */

      ASSERT SAMESTATE ( 0 0 )
      ASSERT SAMESTATE ( 1 1 )
      ASSERT SAMESTATE ( 2 2 )
      ASSERT SAMESTATE ( 3 3 )

      IF MULTISIG ( 2 PREVSTATE( 1 ) PREVSTATE( 2 ) PREVSTATE( 3 ) ) THEN

          /* The owners can modify comissions of third parties and final users */

          ASSERT STATE ( 6 ) GT 0
          ASSERT STATE ( 7 ) GT 0
          ASSERT STATE ( 8 ) GT 0
          ASSERT STATE ( 9 ) GT 0

          /* Transfer the tokens from the vault to the DAO owner */
          RETURN VERIFYOUT (@INPUT STATE( 4 ) @AMOUNT @TOKENID TRUE)

      ENDIF

      /* Only the owners can modify comissions, price and owner and publickey of DAO -  so lets avoid it for the others*/
      ASSERT SAMESTATE ( 4 4 )
      ASSERT SAMESTATE ( 5 5 )
      ASSERT SAMESTATE ( 6 6 )
      ASSERT SAMESTATE ( 7 7 )
      ASSERT SAMESTATE ( 8 8 )
      ASSERT SAMESTATE ( 9 9 )

      /* BUY Dao owner state 5 let transfer the tokens to buyers in exchange for the minima price * AMOUNT */
      IF SIGNEDBY( PREVSTATE( 5 ) ) THEN

        LET vault = STATE ( 0 )
        LET dao = STATE ( 4 )
        LET price = PREVSTATE( 9 )
        LET buyer = STATE ( 10 )
        LET amount = STATE ( 11 )


        ASSERT VERIFYOUT(0 vault amount*price 0x00 FALSE)


        ASSERT VERIFYOUT(1 buyer amount/price @TOKENID TRUE )


        RETURN TRUE

      ENDIF
  -----------------------------------------------------------------

    6.- Meaning and Setting the script variables
      - DAO:
        the tokens must have an script that let the DAO to buy token, the script
        (the exchange contract for the Advertiser user)
        - Create the script into the tokens
          - conditions
            - vault address script ** state 0 **
            - publickey vaullt-1 ** state 1 **
            - publickey vaullt-2 ** state 2 **
            - publickey vaullt-3 ** state 3 **
            - Owner dao address ** state 4 **
            - Owner dao publickey ** state 5 **
            - Third party comission ** state 6 ** to be received by DAO when token is spent from the reward amount.
            - Final user comission ** state 7 ** to be received by DAO when token is spent from the reward amount.
            - If the rewards are not minimas, then a fix % must be set(according to the values of rewards-**Oracle**?)
              ** state 8 **
            - Price of Token ** state 9 **
            - States vars set when the transaction is built to buy tokens
                - buyer address ** state 10 **
                - amount ** state 11 **
                - buyer publickey ** state 12 ** (needed for configuring the tokens bought)

      -----------------------------------------------------------

      7.- Generating VAULT script address:

          Two publickeys are necessary to withdrow funds from the VAULT, the publickeys can be for now from the same nodes
          but in a real case they will be from three different people and nodes.

      -> newscript track:true script:"RETURN MULTISIG(2 0x1CC240481A5494E23E5628E995DAA716254AE7D97924F26859F9186E8A4BA903 0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F 0x39D80173E68EC5B6C299FA245D106C7AAF1DB67ED919939B2D4E3408A4F8F8E4)"

      "response":{
          "script":"RETURN MULTISIG(2 0x1CC240481A5494E23E5628E995DAA716254AE7D97924F26859F9186E8A4BA903 0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F 0x39D80173E68EC5B6C299FA245D106C7AAF1DB67ED919939B2D4E3408A4F8F8E4)",
          "address":"0xE9474BFD827010998FB1F3EA665D8758ABD37A84BA34C9B9EAAB26D7B70881AB",
          "miniaddress":"MxG08798T5VR0JG22CZVCFJT9J5R1QZYF9NY15Q6J4RJQYB4RBRE241YEU2DZQK",
          "simple":false,
          "default":false,
          "publickey":"0x00",
          "track":true
        }
      }



      8.- Transaction instructions to execute the buy of n tokens.
          Note:
          -The change back amounts must also been calculated and be included on the transactions as
          outputs, otherwise all amount of inputs that exceeds of the necessary quanity will be burn and not returned
          back to the owner of it, those cases are not done on the following example as I used the exact amount in order
          not to deal with change back, but it must be calculated and set on the transaction.

          -Note the coins to use on automated system, must be get from the command coins , watch if the coin contains
          enough quantity of minimas or Tokens, if none is found that meet the requirements then several input Coins
          must be used until the amount needed is met.

          ->txncreate id:buy2
          ->txnstate id:buy2 port:0 value:"VAULT address"
          ->txnstate id:buy2 port:1 value:"publickey 1 vault script"
          ->txnstate id:buy2 port:2 value:"publickey 2 vault script"
          ->txnstate id:buy2 port:3 value:"publickey 3 vault script"
          ->txnstate id:buy2 port:4 value:"DAO address"
          ->txnstate id:buy2 port:5 value:"DAO publickey"
          ->txnstate id:buy2 port:6 value:" % Third party comission of the rewards to be received by DAO"
          ->txnstate id:buy2 port:7 value:" % final user comission of rewards to be received by DAO"
          ->txnstate id:buy2 port:8 value:" % of the value of rewards if are not minimas to be received by DAO"
          ->txnstate id:buy2 port:9 value:"1"   // token price (pre-fixed when tokens are created)
          ->txnstate id:buy2 port:10 value:"buyer address"
          ->txnstate id:buy2 port:11 value:"amount of tokens to buy"
          ->txnstate id:buy2 port:12 value:"publickey of the buyer"
          ->txninput id:buy2 coinid:tokens to buy
          ->txninput id:buy2 coinid:minimas to spend on the buy
          ->txnoutput id:buy2 amount:10(the amount of minimas sent to DAO to buy tokens) address:VAULT_address tokenid:0x00 storestate:false
          ->txnoutput id:buy2 amount:10(state 10) address:buyer_address tokenid:token_to_buy storestate:true
          ->txnbasics id:buy2
          ->txnsign id:buy2 publickey:DAO state(5)
          ->txnsign id:buy2 publickey:publickkey_of_the_address_where_minimas_are (coinid 1)
          ->txnsign id:buy2 publickey:publickey_of_the_address_where_tokens_are (coinid 2)
          ->txnpost id:buy2

      9. SCRIPT MDAE:
  -------------------------------------------------------------------------
    - Second part  ## CONFIGURE TOKENS ## :
  -------------------------------------------------------------------------

      /* Configure the tokens bough (12) in an a flashloan kind of contract */
      IF SIGNEDBY( PREVSTATE( 12 ) ) THEN
        ASSERT SAMESTATE ( 10 10 )
        ASSERT SAMESTATE ( 11 11 )
        ASSERT SAMESTATE ( 12 12 )

        /* check if the token is not configured (0) Once configured state(13 is set to 1
          -Flash Loan contract, the token/s are sent to the same addres with the configured state
           variables, so must check that state variables to configure the tokens are set, and
           also must let modify them if they are configured (0,1) values, so when trying to
           send the tokens to the target users the state variable(13) will be set to the value of 2.
        */
        IF STATE (14) EQ 0 OR STATE (14) EQ 1 THEN
          ASSERT VERIFYOUT( @INPUT @ADDRESS @AMOUNT @TOKENID TRUE)
          RETURN TRUE
        ELSE
          /* We check the Advertiser set the state variable 14 to (2=sent) to sent the tokens to final users*/
          ASSERT STATE (14) EQ 2
          RETURN TRUE
        ENDIF

        /* Here goes the part to the final user that let spent the token and distribute the
           rewards and comissions to all parties.
        */
      ENDIF
  -----------------------------------------------------------------

      6.- Meaning and Setting the script variables
        - ADVERTISER:
          the tokens must have an script that let the Advertiser to configure it, the script
          (the flashLoan contract for the Advertiser user)
          - Create the script into the tokens
            - conditions
              - addres of buyer(Advertiser) ** state 10 **
              - amount of tokens bought ** state 11 ** ?? still not sure if it will be necessary ??
              - publickey of buyer(Advertiser) ** state 12 **
              - CAMPAIGN name **state 13**
              - 1 (CONFIGURED) or 0 (NOT CONFIGURED) or 2(SENDING TOKENS) ** state 14 ** the token is configured and can be sent or modified again
              - Amount of reward intermediary party (if there is one) must receive ** state 15 **
              -and type (if there is intermediary) ** state 16 **
              -configure the amount of rewards final user ** state 17 **,
              -configure type final user reward ** state 18 **
              -Avertising configuration:
                -type of publicity ** state 19 **
                  -(0:text ** reserved 23 - 30.... state vars **)
                  -(1:web page)
                  -(2:url image)
                  -(3:url survey / text (using reserved text state variables)
                  -(4:actions (Follow twitter/social networks acount, RT, Likes, p)-using reserved text state variables)
                  -(5:contest using reserver text state vars to set a url or instructions)
                  -(6:others) using reserver text state vars, external sources and rules
                -Content according to type of publicity  Web Page / Image ** state 20 **
                -**configure the rules/requirements to drive how publicity is managed:**
                  -This part can be very complex and done in multiples ways, and it depends on the type of Publicity
                  to be show or managed, so it may require external actor (Oracles, bots, list of instructions....),
                  so it can be a url that indicates or do all necessary actions to check the all steps are followed,so
                  we can divide into two sections:
                    **1.- section 1 to manage how publicity is shown on the target devices/actors**
                    **2.- section 2 to manage how to detect the publicity is viewed or the steps have been followed**
                  We can use all other state variables to manage the former two sections.
                -Actions ** state 21 **
                -Rules ** state 22 ** conditions on what needs to be done to considered a publicity watched.
                -Texts variables publicity ** state 23 - 31 **
            ------------------------------
      7.- State variables by order
        - **state 0** :  VAULT address
        - **state 1** :  Publickey 1 vault script
        - **state 2** :  Publickey 2 vault script
        - **state 3** :  Publickey 3 vault script
        - **state 4** :  DAO address
        - **state 5** :  DAO publickey
        - **state 6** :  % Third party comission of the rewards to be received by DAO
        - **state 7** :  % Final user comission of the rewards to be received by DAO
        - **state 8** :  % of the value of rewards if are not minimas to be received by DAO
        - **state 9** :  Price of the token
        - **state 10** : Buyer address
        - **state 11** : Amount of tokens to buy
        - **state 12** : Buyer publickey
        - **state 13** : CAMPAIGN name
        - **state 14** : State of the token (0,1,2,3) non configured(empty),1 configured, sent, used
        - **state 15** : Amount of rewards to be received by the dapp(developer)
        - **state 16** : Type of rewards dapp (tokenid) (usualy 0x00)
        - **state 17** : Amount of rewards to be received by the final user
        - **state 18** : Type of rewards final user (tokenid) (usually 0x00)
        - **state 19** : Type of advertising (0-6) text(23-31),web, image, survey, actions, contest, others
        - **state 20** : Content according to type of publicity  Web Page / Image
        - **state 21** : Actions (Interaction on twitter, discord, social networks)
        - **state 22** : Conditions on what needs to be done to considered a publicity watched (click)
        - **state 23** : Text 0 publicity
        - **state 24** : Text 1 publicity
        - **state 25** : Text 2 publicity
        - **state 26** : Text 3 publicity
        - **state 27** : Text 4 publicity
        - **state 28** : Text 5 publicity
        - **state 29** : Text 6 publicity
        - **state 30** : Text 7 publicity
        - **state 31** : Text 8 publicity

      -----------------------------------------------------------------




--------------------------- TEST SCRIPT SECUENCE ---FAILS -----------------------
!!!!!  spaces added as script generation deletes them !!!!!
clean script: "ASSERT SAMESTATE(0 0) ASSERT SAMESTATE(1 1) ASSERT SAMESTATE(2 2) ASSERT SAMESTATE(3 3) IF MULTISIG(2 PREVSTATE(1) PREVSTATE(2) PREVSTATE(3)) THEN ASSERT STATE(6) GT 0 ASSERT STATE(7) GT 0 ASSERT STATE(8) GT 0 ASSERT STATE(9) GT 0 RETURN VERIFYOUT(@INPUT PREVSTATE(4) @AMOUNT @TOKENID TRUE) ENDIF ASSERT SAMESTATE(4 4) ASSERT SAMESTATE(5 5) ASSERT SAMESTATE(6 6) ASSERT SAMESTATE(7 7) ASSERT SAMESTATE(8 8) ASSERT SAMESTATE(9 9) IF SIGNEDBY(PREVSTATE(5)) THEN LET vault=STATE(0) LET dao=STATE(4) LET price=PREVSTATE(9) LET buyer=STATE(10) LET amount=STATE(11) ASSERT VERIFYOUT(0 vault amount*price 0x00 FALSE) ASSERT VERIFYOUT(1 buyer amount/price @TOKENID TRUE) RETURN TRUE ENDIF IF SIGNEDBY(PREVSTATE(12)) THEN ASSERT SAMESTATE(10 10) ASSERT SAMESTATE(11 11) ASSERT SAMESTATE(12 12) IF STATE(14) EQ 0 OR STATE(14) EQ 1 THEN ASSERT VERIFYOUT(@INPUT @ADDRESS @AMOUNT @TOKENID TRUE) RETURN TRUE ELSE ASSERT STATE(14) EQ 2 RETURN TRUE ENDIF ENDIF"



`
-> tokencreate name:"dddMDAE" amount:10000 decimals:0 state:{"0":"0xE9474BFD827010998FB1F3EA665D8758ABD37A84BA34C9B9EAAB26D7B70881AB","1":"0x1CC240481A5494E23E5628E995DAA716254AE7D97924F26859F9186E8A4BA903","2":"0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F","3":"0x39D80173E68EC5B6C299FA245D106C7AAF1DB67ED919939B2D4E3408A4F8F8E4","4":"0x614190606CD54F2CF78D06813CE1BF4C71438C7897234C7D0F788D4F65F84BDE","5":"0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F","6":"0.2","7":"0.2","8":"0.2","9":"1"} script:"ASSERT SAMESTATE(0 0) ASSERT SAMESTATE(1 1) ASSERT SAMESTATE(2 2) ASSERT SAMESTATE(3 3) IF MULTISIG(2 PREVSTATE(1) PREVSTATE(2) PREVSTATE(3)) THEN ASSERT STATE(6) GT 0 ASSERT STATE(7) GT 0 ASSERT STATE(8) GT 0 ASSERT STATE(9) GT 0 RETURN VERIFYOUT(@INPUT PREVSTATE(4) @AMOUNT @TOKENID TRUE) ENDIF ASSERT SAMESTATE(4 4) ASSERT SAMESTATE(5 5) ASSERT SAMESTATE(6 6) ASSERT SAMESTATE(7 7) ASSERT SAMESTATE(8 8) ASSERT SAMESTATE(9 9) IF SIGNEDBY(PREVSTATE(5)) THEN LET vault=STATE(0) LET dao=STATE(4) LET price=PREVSTATE(9) LET buyer=STATE(10) LET amount=STATE(11) ASSERT VERIFYOUT(0 vault amount*price 0x00 FALSE) ASSERT VERIFYOUT(1 buyer amount/price @TOKENID TRUE) RETURN TRUE ENDIF IF SIGNEDBY(PREVSTATE(12)) THEN ASSERT SAMESTATE(10 10) ASSERT SAMESTATE(11 11) ASSERT SAMESTATE(12 12) IF STATE(14) EQ 0 OR STATE(14) EQ 1 THEN ASSERT VERIFYOUT(@INPUT @ADDRESS @AMOUNT @TOKENID TRUE) RETURN TRUE ELSE ASSERT STATE(14) EQ 2 RETURN TRUE ENDIF ENDIF"
`

VAULT address: "0xE9474BFD827010998FB1F3EA665D8758ABD37A84BA34C9B9EAAB26D7B70881AB",
DAO address:0x614190606CD54F2CF78D06813CE1BF4C71438C7897234C7D0F788D4F65F84BDE
DAO publickey:0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F

Minimas:
------coinid: 10 minimas: 0x3A44C22ADB666D6A96AFB5C07068ED4489CD0CBD05E822AB49658BB931E78259
------address 10 minimas: 0x614190606CD54F2CF78D06813CE1BF4C71438C7897234C7D0F788D4F65F84BDE
------publickey: 0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F

Tokens:
------address where tokens are : 0xF9DE50AAF7A701BBE8E472C5F52A3A55611C6C78797AD3BE4296CCFDA62E3361
------publickey : 0x39D80173E68EC5B6C299FA245D106C7AAF1DB67ED919939B2D4E3408A4F8F8E4
------tokenid: 0x58C82F9B29C2F0E6E889529F5443C81D3A1D49D94681BF616FBA5158B50B5028
------coinid: tokens: 0x0DA7BE24CA3852B5EB32263FE334FD40A9BD7B7946D9F5739008EC7890DFFC11

`
buyer address: 0x966129DE47ECFA68927B83B96DFD9CCDE7B3F12D9C882FBAF830450CABD8AA89
buyer publickey: 0x0D04EEB70EDF1E6E71AA5A0927F5B4ED2B7B4E7BADC064A4B99D2A15CE72395E
`

-----> minima coins are on the same address (4) publickkey(5) so only 2 signtarures are needed
->txncreate id:buy7
->txnstate id:buy7 port:0 value:"0xE9474BFD827010998FB1F3EA665D8758ABD37A84BA34C9B9EAAB26D7B70881AB"
->txnstate id:buy7 port:1 value:"0x1CC240481A5494E23E5628E995DAA716254AE7D97924F26859F9186E8A4BA903"
->txnstate id:buy7 port:2 value:"0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F"
->txnstate id:buy7 port:3 value:"0x39D80173E68EC5B6C299FA245D106C7AAF1DB67ED919939B2D4E3408A4F8F8E4"
->txnstate id:buy7 port:4 value:"0x614190606CD54F2CF78D06813CE1BF4C71438C7897234C7D0F788D4F65F84BDE"
->txnstate id:buy7 port:5 value:"0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F"
->txnstate id:buy7 port:6 value:"0.2"
->txnstate id:buy7 port:7 value:"0.2"
->txnstate id:buy7 port:8 value:"0.2"
->txnstate id:buy7 port:9 value:"1"
->txnstate id:buy7 port:10 value:"0x966129DE47ECFA68927B83B96DFD9CCDE7B3F12D9C882FBAF830450CABD8AA89"
->txnstate id:buy7 port:11 value:"10"
->txnstate id:buy7 port:12 value:"0x0D04EEB70EDF1E6E71AA5A0927F5B4ED2B7B4E7BADC064A4B99D2A15CE72395E"
->txninput id:buy7 coinid:0x0DA7BE24CA3852B5EB32263FE334FD40A9BD7B7946D9F5739008EC7890DFFC11
->txninput id:buy7 coinid:0x3A44C22ADB666D6A96AFB5C07068ED4489CD0CBD05E822AB49658BB931E78259
->txnoutput id:buy7 amount:10 address:0xE9474BFD827010998FB1F3EA665D8758ABD37A84BA34C9B9EAAB26D7B70881AB tokenid:0x00 storestate:false
->txnoutput id:buy7 amount:10 address:0x966129DE47ECFA68927B83B96DFD9CCDE7B3F12D9C882FBAF830450CABD8AA89 tokenid:0x58C82F9B29C2F0E6E889529F5443C81D3A1D49D94681BF616FBA5158B50B5028 storestate:true
->txnbasics id:buy7
->txnsign id:buy7 publickey:0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F
->txnsign id:buy7 publickey:0x39D80173E68EC5B6C299FA245D106C7AAF1DB67ED919939B2D4E3408A4F8F8E4
->txnpost id:buy7
`
- it fails, every test done ends failing, swaping coind also fails , swaping outputs also fails....
----------------------------------- END TEST SEQUENCE -----------------------------------


--------------------------------------------------------------------------------------------------
--------- new setup to test the system Advertiser and DAO on my nodes --------------------------
VAULT script:
vault1:0x39383D810DC3A733E22344E02B97C940EB7A7AD4FAE918403E71FB5998C9E3C8
vault2:0x62A8D572CB69B82F3ED3AE215D16F340A0EF231164D9557D6B10D24D70C4DD06
valut3:0x1B17E4607ABDD642A65409A1D27D28DF628219D77B4512FA3D58A4BBE613F309
->newscript track:true script:"RETURN MULTISIG(2 0x39383D810DC3A733E22344E02B97C940EB7A7AD4FAE918403E71FB5998C9E3C8 0x62A8D572CB69B82F3ED3AE215D16F340A0EF231164D9557D6B10D24D70C4DD06 0x1B17E4607ABDD642A65409A1D27D28DF628219D77B4512FA3D58A4BBE613F309)"
"response":{
    "script":"RETURN MULTISIG(2 0x39383D810DC3A733E22344E02B97C940EB7A7AD4FAE918403E71FB5998C9E3C8 0x62A8D572CB69B82F3ED3AE215D16F340A0EF231164D9557D6B10D24D70C4DD06 0x1B17E4607ABDD642A65409A1D27D28DF628219D77B4512FA3D58A4BBE613F309)",
    "address":"0xA2784D94B13C114BB3937118BB2419A3712D871C767202A3B178F6905728D0DA",
    "miniaddress":"MxG0852F16P9C9S255R74RH32TW86D3E4MZE73ME81A7CBZUQ85EA6GRABENMH3",
    "simple":false,
    "default":false,
    "publickey":"0x00",
    "track":true
  }

VAULT address: "0xA2784D94B13C114BB3937118BB2419A3712D871C767202A3B178F6905728D0DA",
DAO address:0x4712CD047BDC4233788709BF5258F5F88495B986CE1F0AFAEA9A89E8EEAFB441
DAO publickey:0xE9C2AD0CF3E65DC3F85DFB9C23FCE05B1EC4CEF09ADE5D48B31E347054E772EC

Minimas:
------coinid: 10 minimas: 0x3A44C22ADB666D6A96AFB5C07068ED4489CD0CBD05E822AB49658BB931E78259
------address 10 minimas: 0x614190606CD54F2CF78D06813CE1BF4C71438C7897234C7D0F788D4F65F84BDE
------publickey: 0x0826603887FC6C2BF5AD2B5E371B85918D1426B5C11FA23C8248613AFB13822F

Tokens:
------address where tokens are : 0x4712CD047BDC4233788709BF5258F5F88495B986CE1F0AFAEA9A89E8EEAFB441
--!!----publickey : 0x39D80173E68EC5B6C299FA245D106C7AAF1DB67ED919939B2D4E3408A4F8F8E4
------tokenid: 0x6F3D1B097DD5B73FF6D9CC018ADB2524BF1F854B32820DC695ECD58E199363B6
------coinid: tokens: 0x2C1DD6F5320A49E4C8892B6795836F96D99FFC013CE8CC48EDCC766796D132D4

`
buyer address: 0xE3DD00E350E6D82C57C7E17BC448116A015C3D40CFEE16FF004F1C662C086739
buyer publickey: 0xE84A942B393A2966362B28932E84BEC29CE8163D294D43C6B34DC0B7763B8203
`
`
-> tokencreate name:"aMDAE" amount:5000 decimals:0 state:{"0":"0xA2784D94B13C114BB3937118BB2419A3712D871C767202A3B178F6905728D0DA","1":"0x39383D810DC3A733E22344E02B97C940EB7A7AD4FAE918403E71FB5998C9E3C8","2":"0x62A8D572CB69B82F3ED3AE215D16F340A0EF231164D9557D6B10D24D70C4DD06","3":"0x1B17E4607ABDD642A65409A1D27D28DF628219D77B4512FA3D58A4BBE613F309","4":"0x4712CD047BDC4233788709BF5258F5F88495B986CE1F0AFAEA9A89E8EEAFB441","5":"0xE9C2AD0CF3E65DC3F85DFB9C23FCE05B1EC4CEF09ADE5D48B31E347054E772EC","6":"0.2","7":"0.2","8":"0.2","9":"1"}
`
